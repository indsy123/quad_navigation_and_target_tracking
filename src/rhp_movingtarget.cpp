#include <rhp_movingtarget.h>


using namespace std;
Eigen::Matrix4f lidar_pose;
//std::ofstream outdata;
//outdata.open("generated_trajectory.txt", std::ios::out|std::ios::binary);


void planner::getParameters()
{
  
  ROS_INFO("getting all the parameters from launch file");
  // planner parameters
  nh_.param<std::string>("run_number", run_number, "0");
  nh_.param<std::string>("mode", mode, "simulation");
  nh_.param<std::string>("px4_controller_type", px4_controller_type, "position"); 
  nh_.param<std::string>("odometry_topic", odom_topic, "/odometry_topic");    
  nh_.param<double>("odometry_frequency", odom_frequency, 100.0);  
  nh_.param<std::string>("pointcloud_topic", pc_topic, "/pointcloud_topic");    
  nh_.param<double>("pointcloud_frequency", pc_frequency, 15.0);  
  nh_.param<std::string>("cmd_topic", cmd_topic, "/cmd_topic"); 
  nh_.param<std::string>("posecmd_topic", posecmd_topic, "/position_cmd_topic");
  nh_.param<std::string>("target_topic", target_topic, "/target_topic"); 
  nh_.param<double>("maxTrajectoryLength", maxR, 6.0); 
  nh_.param<double>("minTrajectoryLength", minR, 2.0);
  nh_.param<double>("fov_x", xFOV, 60.0);
  nh_.param<double>("fov_y", yFOV, 60.0);
  nh_.param<double>("mass", mass, 1.0);
  nh_.param<double>("max_thrust", maxT, 35.0);
  nh_.param<double>("max_velocity", maxV, 10.0);
  nh_.param<double>("max_angularvelocity", maxAngV, 35.0);
  //nh_.param<double>("average_velocity", avgV, 1.0);
  nh_.param<double>("hovering_height", hHover, 1.0);
  nh_.param<std::vector <double>>("initial_position", iPosition, {0, 0, 0.08});
  nh_.param<std::vector <double>>("final_goal", final_goal, {0, 0, 2});   
  //additional parameters for controller
  nh_.param<double>("tau_rp", tau_rp, 1.0);
  nh_.param<double>("tau_yaw", tau_yaw, 1.0);
  nh_.param<std::vector <double>>("kx", kx, {5, 5, 5});
  nh_.param<std::vector <double>>("kv", kv, {4, 4, 4});
  nh_.param<std::vector <double>>("kR", kR, {5, 5, 5});
  nh_.param<std::vector <double>>("kOmega", kOmega, {4, 4, 4});
  // paramters for pointcloud processing
  nh_.param<std::vector <double>>("cogTbase", cgTb, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0});
  nh_.param<std::vector <double>>("baseTcoc", bToc, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0});

  nh_.param<double>("battery_percentage", _bat, 100.0);
  nh_.param<std::string>("battery_topic", battery_topic, "/battery_topic"); 

  // Eigen matrix is filled column wise 
  cogTbase << cgTb[0], cgTb[1], cgTb[2], cgTb[3], 
              cgTb[4], cgTb[5], cgTb[6], cgTb[7], 
              cgTb[8], cgTb[9], cgTb[10], cgTb[11], 
              cgTb[12], cgTb[13], cgTb[14], cgTb[15];

  baseTcoc << bToc[0], bToc[1], bToc[2], bToc[3], 
              bToc[4], bToc[5], bToc[6], bToc[7], 
              bToc[8], bToc[9], bToc[10], bToc[11], 
              bToc[12], bToc[13], bToc[14], bToc[15];

  cogTcoc = cogTbase * baseTcoc;

  delt = 1.0/odom_frequency;
  controlHorizonTime = 1.1/pc_frequency;
  initialHoveringPosition = {iPosition[0], iPosition[1], hHover};

  outdata.open("mv_subscribed_trajectory"+run_number+".txt", std::ios::out|std::ios::binary);
  outdata1.open("mv_generated_trajectory"+run_number+".txt", std::ios::out|std::ios::binary);
  outdata2.open("mv_other_parameters"+run_number+".txt", std::ios::out|std::ios::binary);

}

void planner::initializeSubscribers()
{
  ROS_INFO("Initializing Planner Subscribers");
  odom_sub = nh_.subscribe(odom_topic.c_str(), 1, &planner::odometry_callback, this, ros::TransportHints().tcpNoDelay(true));  
  pc_sub = nh_.subscribe(pc_topic.c_str(), 1, &planner::pointcloud_callback, this, ros::TransportHints().tcpNoDelay(true)); 
  //bat_sub = nh_.subscribe(battery_topic.c_str(), 1, &planner::batteryCb, this, ros::TransportHints().tcpNoDelay(true)); 
  target_sub = nh_.subscribe(target_topic.c_str(), 1, &planner::target_callback, this, ros::TransportHints().tcpNoDelay(true));
}

void planner::initializePublishers()
{
  ROS_INFO("Initializing Planner Publishers");
  bool latch;
  if (mode ==  "simulation")
  {
    cmd_pub = nh_.advertise<mav_msgs::Actuators>(cmd_topic.c_str(), 1, latch=true);
  }
  else if (mode == "hardware")
  {
    cmd_pub = nh_.advertise<mavros_msgs::AttitudeTarget>(cmd_topic.c_str(), 1, latch=true);
    pose_pub = nh_.advertise<mavros_msgs::PositionTarget>(posecmd_topic.c_str(), 1, latch=true);
  }
  pc_pub = nh_.advertise<sensor_msgs::PointCloud2>("/udrone1/transformed_points", 1, latch=true);
  ensemble_pub = nh_.advertise<sensor_msgs::PointCloud2>("/udrone1/ensemble", 1, latch=true);
  best_traj_pub = nh_.advertise<sensor_msgs::PointCloud2>("/udrone1/best_trajectory", 1, latch=true);
  selected_traj_pub = nh_.advertise<sensor_msgs::PointCloud2>("/udrone1/selected_trajectory", 1, latch=true);
}

void planner::batteryCb(const sensor_msgs::BatteryState::ConstPtr& msg)
{
  percentage = 100 * msg->percentage;
  if (percentage >= 40.0 && percentage <= 100.0)
  {
    // 2nd order polynomial fit with battery percentage and max thrust generated by propellers
    maxT = -0.0011847886*percentage*percentage + 0.2761785826*percentage + 20.3783082048;
  }
  else
  {
    maxT = 50.0; // a high value so that the quad cant take off
    cout<<"Not safe for flying: Battery percentage is less than 40 or greater than 100"<<endl; 
  }
}


void planner::checkConvergance(VectorXd& goalState, VectorXd& currentState, bool& waypointReached, double& convergance)
{
  convergance = sqrt(pow(goalState(0)-currentState(0), 2) + pow(goalState(4)-currentState(4), 2) + pow(goalState(8)-currentState(8), 2));
  if (convergance <= 0.1)
  {
    waypointReached  = true;
  }
}

void planner::finalTrajectory(VectorXd& px, VectorXd& py, VectorXd& pz, Vector4d& yaw_coeff, double& T0, double& T)
{

  int n = int(T/delt) + 1;
  VectorXd timePoints(n);
  timePoints[0] = T0;
  for (int i = 0; i < (n - 1); ++i)
  {
    timePoints[i] =  delt * i;
  }
  timePoints[n-1] = T;

  double start_time = ros::Time::now().toSec();
  double _a, _b, _c, _d, _e, _f;
  _a = 1.0/5040; _b = 1.0/720; _c = 1.0/120; _d = 1.0/24; _e = 1.0/6; _f = 0.5;

  for (int i=0; i<timePoints.size(); i++)
  {
    double t = timePoints(i);
    double _time = start_time + t;
    double x, y, z, vx, vy, vz, ax, ay, az, jx, jy, jz, phi, phi_r;
    pcl::PointXYZ pt;
    x = px(0)*t*t*t*t*t*t*t*_a - px(1)*t*t*t*t*t*t*_b + px(2)*t*t*t*t*t*_c - px(3)*t*t*t*t*_d + px(4)*t*t*t*_e + px(5)* t*t*_f + px(6)*t + px(7);
    y = py(0)*t*t*t*t*t*t*t*_a - py(1)*t*t*t*t*t*t*_b + py(2)*t*t*t*t*t*_c - py(3)*t*t*t*t*_d + py(4)*t*t*t*_e + py(5)* t*t*_f + py(6)*t + py(7);
    z = pz(0)*t*t*t*t*t*t*t*_a - pz(1)*t*t*t*t*t*t*_b + pz(2)*t*t*t*t*t*_c - pz(3)*t*t*t*t*_d + pz(4)*t*t*t*_e + pz(5)* t*t*_f + pz(6)*t + pz(7);

    vx = px(0)*t*t*t*t*t*t*_b - px(1)*t*t*t*t*t*_c + px(2)*t*t*t*t*_d - px(3)*t*t*t*_e + px(4)*t*t*_f + px(5)* t + px(6);
    vy = py(0)*t*t*t*t*t*t*_b - py(1)*t*t*t*t*t*_c + py(2)*t*t*t*t*_d - py(3)*t*t*t*_e + py(4)*t*t*_f + py(5)* t + py(6);
    vz = pz(0)*t*t*t*t*t*t*_b - pz(1)*t*t*t*t*t*_c + pz(2)*t*t*t*t*_d - pz(3)*t*t*t*_e + pz(4)*t*t*_f + pz(5)* t + pz(6);

    ax = px(0)*t*t*t*t*t*_c - px(1)*t*t*t*t*_d + px(2)*t*t*t*_e - px(3)*t*t*_f + px(4)*t + px(5);
    ay = py(0)*t*t*t*t*t*_c - py(1)*t*t*t*t*_d + py(2)*t*t*t*_e - py(3)*t*t*_f + py(4)*t + py(5);
    az = pz(0)*t*t*t*t*t*_c - pz(1)*t*t*t*t*_d + pz(2)*t*t*t*_e - pz(3)*t*t*_f + pz(4)*t + pz(5);

    phi = yaw_coeff(0) + yaw_coeff(1)*t + yaw_coeff(2) *t*t + yaw_coeff(3) *t*t*t;
    phi_r = yaw_coeff(1) + 2 *yaw_coeff(2) *t + 3 *yaw_coeff(3) *t*t;

    outdata1 << _time <<","<<x<<","<<y<<","<<z<<","<<vx<<","<<vy<<","<<vz<<","<<ax<<","<<ay<<","<<az<<","<<phi<<","<<phi_r<<endl;

    pt.x = x;
    pt.y = y;
    pt.z = z;
    traj_cloud.points.push_back(pt);
    
    traj_global_time.push_back(_time);
    xdes.push_back(x); ydes.push_back(y); zdes.push_back(z);
    vxdes.push_back(vx); vydes.push_back(vy); vzdes.push_back(vz);
    axdes.push_back(ax); aydes.push_back(ay); azdes.push_back(az);
    yawdes.push_back(phi); yawratedes.push_back(phi_r);
    if (traj_global_time.size() >= 2000)
    {
      traj_global_time.erase(traj_global_time.begin());
      xdes.erase(xdes.begin()); ydes.erase(ydes.begin()); zdes.erase(zdes.begin());
      vxdes.erase(vxdes.begin()); vydes.erase(vydes.begin()); vzdes.erase(vzdes.begin());
      axdes.erase(axdes.begin()); aydes.erase(aydes.begin()); azdes.erase(azdes.begin());
      yawdes.erase(yawdes.begin()); yawratedes.erase(yawratedes.begin());
    }
    
  }
  trajectoryAvailable = true;
  sensor_msgs::PointCloud2 pc_traj;
  pcl::toROSMsg(traj_cloud, pc_traj);
  pc_traj.header.frame_id = "world";
  pc_traj.header.stamp = ros::Time::now();
  best_traj_pub.publish(pc_traj);
}

void planner::_factoredVelocity(double& time_diff, Vector3d& targetPose, VectorXd& currentState, double& safetyDistance, double& maxV, double& maxVel)
{
  double kvel = 0.4;
  double kdist = 0.5;
  double timefactor = erf(kvel * time_diff);
  double dist2target = sqrt(pow(targetPose(0)-currentState(0), 2) + 
                            pow(targetPose(1)-currentState(4), 2) +
                            pow(targetPose(2)-currentState(8), 2));
  double dist2targetfactor = erf(kdist * (dist2target-safetyDistance));
  maxVel = max(0.5, timefactor*dist2targetfactor*maxV);
}

void planner::target_callback(const nav_msgs::Odometry::ConstPtr& msg)
{
  targetPose << msg->pose.pose.position.x, msg->pose.pose.position.y, 0.8 ;
  targetVel << msg->twist.twist.linear.x, msg->twist.twist.linear.y, msg->twist.twist.linear.z;
  if (isnan(targetPose(0)))
  {
    targetpose_available = false;
  }
  else
  {   
    targetpose_available = true;


    static tf::TransformBroadcaster targ_transform;
    tf::Transform trans;
    trans.setOrigin(tf::Vector3(msg->pose.pose.position.x, msg->pose.pose.position.y, msg->pose.pose.position.z));
    tf::Quaternion qt;
    qt[0] = msg->pose.pose.orientation.x;
    qt[1] = msg->pose.pose.orientation.y;
    qt[2] = msg->pose.pose.orientation.z;
    qt[3] = msg->pose.pose.orientation.w;
    trans.setRotation(qt);
    targ_transform.sendTransform(tf::StampedTransform(trans, ros::Time::now(), "/world", "/udrone1/target"));
  }
}

void planner::odometry_callback(const nav_msgs::Odometry::ConstPtr& msg)
{
  current_time = msg->header.stamp.toSec();
  Eigen::Quaterniond q;
  q.w() = msg->pose.pose.orientation.w;
  q.x() = msg->pose.pose.orientation.x;
  q.y() = msg->pose.pose.orientation.y;
  q.z() = msg->pose.pose.orientation.z;
  Eigen::Matrix3d R = q.toRotationMatrix();
  dronePose = Eigen::Matrix4d::Identity();
  dronePose.block(0,0,3,3) = R;
  dronePose(0,3) = msg->pose.pose.position.x;
  dronePose(1,3) = msg->pose.pose.position.y;
  dronePose(2,3) = msg->pose.pose.position.z;

  static tf::TransformBroadcaster br1, br2;
  tf::Transform transform;
  transform.setOrigin(tf::Vector3(dronePose(0,3), dronePose(1,3), dronePose(2,3)));
  tf::Quaternion qq;
  qq[0] = msg->pose.pose.orientation.x;
  qq[1] = msg->pose.pose.orientation.y;
  qq[2] = msg->pose.pose.orientation.z;
  qq[3] = msg->pose.pose.orientation.w;
  transform.setRotation(qq);
  br1.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "/world", "/udrone1/odom"));

  tf::Transform transform2;
  transform2.setOrigin(tf::Vector3(cogTcoc(0,3), cogTcoc(1,3), cogTcoc(2,3)));
  tf::Matrix3x3 tf3d;
  tf3d.setValue(cogTcoc(0,0), cogTcoc(0,1), cogTcoc(0,2), 
                cogTcoc(1,0), cogTcoc(1,1), cogTcoc(1,2),
		cogTcoc(2,0), cogTcoc(2,1), cogTcoc(2,2));     

  tf::Quaternion tfqt;
  tf3d.getRotation(tfqt);
  transform2.setRotation(tfqt);
  br2.sendTransform(tf::StampedTransform(transform2, ros::Time::now(), "/udrone1/odom", "/udrone1/d435_color_optical_frame"));

  // these two lines are needed only for rotorS, because the linear velocity is expressed in body frame
  Eigen::Vector3d Vc = {msg->twist.twist.linear.x, msg->twist.twist.linear.y, msg->twist.twist.linear.z};
  Vc = R*Vc;
  // so these lines convert that into inertial frame, not needed eventually for hardware tests.

  if (odom_counter == 0)
  {
    initialState << msg->pose.pose.position.x, Vc(0), 0.0, 0.0, 
                    msg->pose.pose.position.y, Vc(1), 0.0, 0.0, 
                    msg->pose.pose.position.z, Vc(2), 0.0, 0.0;
    
  }

  /*if (abs(Vc(0)) < 0.01  && abs(Vc(1)) < 0.01)
  {
    initialState << msg->pose.pose.position.x, Vc(0), 0.0, 0.0, 
                    msg->pose.pose.position.y, Vc(1), 0.0, 0.0, 
                    msg->pose.pose.position.z+0.1, Vc(2), 0.0, 0.0;    
  }*/

  currentState << msg->pose.pose.position.x, Vc(0), 0.0, 0.0, 
                  msg->pose.pose.position.y, Vc(1), 0.0, 0.0, 
                  msg->pose.pose.position.z, Vc(2), 0.0, 0.0;
  

  currentYaw = tf2::getYaw(msg->pose.pose.orientation);
  currentYawrate = 0.0;

  if (trajectoryAvailable)
  {
    int j;
    for (int i = traj_global_time.size()-1; i >= 0; --i)
    {
      if (traj_global_time[i] < current_time)
      {
        j = i;
        break;
      }
      else
      {
        j = traj_global_time.size()-1;
      }      
    }


    // last two on desired state are yaw and yaw_rate
    desiredState<< xdes[j], vxdes[j], axdes[j], 0.0, ydes[j], vydes[j], aydes[j], 0.0, zdes[j], vzdes[j], azdes[j], 0.0, yawdes[j], yawratedes[j];
    
    outdata<<traj_global_time[j]<<","<<desiredState(0)<<","<<currentState(0)<<","<<desiredState(4)<<","<<currentState(4)<<","<<desiredState(8)
            <<","<<currentState(8)<<","<<desiredState(1)<<","<<currentState(1)<<","<<desiredState(5)<<","<<currentState(5)<<","
            <<desiredState(9)<<","<<currentState(9)<<","<<desiredState(2)<<","<<currentState(2)<<","<<desiredState(6)<<","<<currentState(6)<<","
            <<desiredState(10)<<","<<currentState(10)<<","<<desiredState(12)<<","<<currentYaw<<","<<desiredState(13)<<","<<currentYawrate<<endl;

    if (mode == "simulation")
    {
      controller_simulation control;
      Eigen::VectorXd w(6);
      control.calculateCommands(msg, desiredState, kx, kx, kR, kOmega, mass, w);

      mav_msgs::Actuators cmd_msg;
      cmd_msg.header.stamp = msg->header.stamp;
      for (int i; i< w.size(); i++)
      {
        cmd_msg.angular_velocities.push_back(w(i)); 
      }
      cmd_pub.publish(cmd_msg);
    }
    else if (mode == "hardware")
    {
      if (px4_controller_type == "attitude")
      {
        controller_px4 control;
        Eigen::VectorXd w(4);
        control.calculateCommands(msg, desiredState, kx, kx, tau_rp, tau_yaw, maxT, mass, w);
        mavros_msgs::AttitudeTarget cmd_msg;
        cmd_msg.header.stamp = ros::Time::now();//msg->header.stamp;
        cmd_msg.type_mask = 128;
        cmd_msg.body_rate.x = w(0);
        cmd_msg.body_rate.y = w(1);
        cmd_msg.body_rate.z = w(2);
        cmd_msg.thrust = w(3);
        cmd_pub.publish(cmd_msg);
      }
      else if(px4_controller_type =="position")
      {

	//uint16 type_mask
	// uint16 IGNORE_PX = 1 # position ignore flags
	// uint16 IGNORE_PY = 2
	// uint16 IGNORE_PZ = 4
	// uint16 IGNORE_VX = 8 # velocity vector ignore flags
	// uint16 IGNORE_VY = 16
	// uint16 IGNORE_VZ = 32
	// uint16 IGNORE_AFX = 64 # acceleration/force vector ignore flags
	// uint16 IGNORE_AFY = 128
	// uint16 IGNORE_AFZ = 256
	// uint16 FORCE = 512
	// uint16 IGNORE_YAW = 1028
	// uint16 IGNORE_YAW_RATE = 2014

        mavros_msgs::PositionTarget posecmd_msg;
	posecmd_msg.coordinate_frame = mavros_msgs::PositionTarget::FRAME_LOCAL_NED;
	posecmd_msg.header.stamp = ros::Time::now();
        posecmd_msg.type_mask = 8+16+32+64+128+256+512;

	posecmd_msg.position.x = desiredState(0);
	posecmd_msg.position.y = desiredState(4);
	posecmd_msg.position.z = desiredState(8);
	posecmd_msg.velocity.x = desiredState(1);
	posecmd_msg.velocity.y = desiredState(5);
	posecmd_msg.velocity.z = desiredState(9);
	posecmd_msg.acceleration_or_force.x = desiredState(2);
	posecmd_msg.acceleration_or_force.y = desiredState(6);
	posecmd_msg.acceleration_or_force.z = desiredState(10);
	posecmd_msg.yaw = desiredState(12);
	posecmd_msg.yaw_rate = desiredState(13);
        pose_pub.publish(posecmd_msg);
        //cout <<desiredState(12)<<","<<desiredState(13)<<endl; 
      }
    }
    

  }
  odom_counter += 1;
}

void planner::pointcloud_callback(const sensor_msgs::PointCloud2ConstPtr& cloud_in)
{

  ros::Time t0 = ros::Time::now();   
  double convergance, time_taken;
  double T0 = 0.0;


  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out (new pcl::PointCloud<pcl::PointXYZ>);
  pcl::PointCloud<pcl::PointXYZ>::Ptr ensemble_cloud (new pcl::PointCloud<pcl::PointXYZ>);
  vector<vector<double>> points;
  vector<vector<double>> availablepoints;
  
  bool badTrajectory;
  ensembleGeneration ensemble;
  OptimalControlTrajectory trajectory;
  ensemble.processPointcloud(cloud_in, xFOV, yFOV, maxR, cogTcoc, dronePose, cloud_out);
  Eigen::Vector2d yaw_ic, yaw_fc;
  Eigen::Vector4d yaw_coeff;


  if (pc_counter == 0 || replan) 
  {
    if (pc_counter == 0)
    {
      initialState = currentState;
      goalState << initialState(0), 0.0, 0.0, 0.0, initialState(4), 0.0, 0.0, 0.0, hHover, 0.0, 0.0, 0.0;

      yaw_ic << currentYaw, currentYawrate;
      yaw_fc = yaw_ic;

      double hoverMaxV = 0.5;
      trajectory.generateTrajectory(initialState, goalState, hoverMaxV, maxT, maxAngV, mass, px, py, pz, T, badTrajectory);
      trajectory.yawCoeff(yaw_ic, yaw_fc, T, yaw_coeff);
      finalTrajectory(px, py, pz, yaw_coeff, T0, T);
      cout <<"initial trajectory generated"<<endl;
      ros::Duration(T+6).sleep();
      replan = true;
      initialState = goalState;
    }
    else //receding horizon plannning with moving target 
    { 
      if (targetpose_available == true)
      {

        if (rhp_counter == 0){replanning_starttme = ros::Time::now().toSec();}       

        double safetyDistance = 0.5;
        double maxVel;
        double time_diff = current_time-replanning_starttme;
        _factoredVelocity(time_diff, targetPose, currentState, safetyDistance, maxV, maxVel);

        // goal state can't be the target state, because the target is on the ground
        // it is therefore 0.5m above the target
        goalState << targetPose(0), 0.0, 0.0, 0.0, targetPose(1), 0.0, 0.0, 0.0, targetPose(2), 0.0, 0.0, 0.0;
        
        
        ensemble.generateEnsemble(dronePose, xFOV, yFOV, maxR, minR, maxVel, points);
        ensemble.checkcollosionGetcost(cloud_out, initialState, goalState, maxT, maxAngV, mass, points, availablepoints, ensemble_cloud, outdata2);
        //cout <<"total points:"<<points.size()<<", available points:"<<availablepoints.size()<<endl;

        if (availablepoints.size() != 0)
        {
          ensemble.generateLocalgoal(availablepoints, local_goal);          
          sensor_msgs::PointCloud2 pc_ensemble;
          pcl::toROSMsg(*ensemble_cloud, pc_ensemble);
          pc_ensemble.header.frame_id = "world";
          pc_ensemble.header.stamp = ros::Time::now();
          ensemble_pub.publish(pc_ensemble);
          localGoal << local_goal[0], 0.0, 0.0, 0.0, local_goal[1], 0.0, 0.0, 0.0, local_goal[2], 0.0, 0.0, 0.0;

          if (abs(localGoal(0) - initialState(0))<0.01 && abs(localGoal(4) - initialState(4))<0.01)
          {desiredYaw = 0;}
          else {desiredYaw = atan2(localGoal(4) - initialState(4), localGoal(0) - initialState(0));}


          if (rhp_counter == 0){yaw_ic << currentYaw, currentYawrate;}
          else{yaw_ic << controlHorizonYaw, controlHorizonYawrate;}
          
          yaw_fc << desiredYaw, 0.0;

          trajectory.generateTrajectory(initialState, localGoal, local_goal[3], maxT, maxAngV, mass, px, py, pz, T, badTrajectory);        
          trajectory.yawCoeff(yaw_ic, yaw_fc, T, yaw_coeff);
          controlHorizonYaw = yaw_coeff(0) + yaw_coeff(1)*controlHorizonTime + yaw_coeff(2)*pow(controlHorizonTime,2) + 
                              yaw_coeff(3)*pow(controlHorizonTime,3);
          controlHorizonYawrate = yaw_coeff(1) + 2 * yaw_coeff(2) * controlHorizonTime + 3 * yaw_coeff(3) * pow(controlHorizonTime,2);

          trajectory.getControlHorizonPoint(px, py, pz, controlHorizonTime, initialState);
          finalTrajectory(px, py, pz, yaw_coeff, T0, controlHorizonTime);

          replan = true;
          //outdata2 <<  cloud_in->height * cloud_in->width <<","<<availablepoints.size()<<","<<fixed << time_taken << setprecision(7)<<endl;          
        }
        else
        {
          cout <<"no points in the fov"<<endl;
          local_goal[0] = localGoal(0); local_goal[1] = localGoal(1); local_goal[2] = localGoal(2); local_goal[3] = maxVel;
          finalTrajectory(px, py, pz, yaw_coeff, controlHorizonTime, T);
          replan = true;
        }
        
        //convergance = sqrt(pow(goalState(0)-currentState(0), 2) + pow(goalState(4)-currentState(4), 2) + pow(goalState(8)-currentState(8), 2));

        rhp_counter += 1; 
        int n = int(T/delt) + 1;
        for (int i = 0; i < (n - 1); ++i)
        {
          double t = delt * i;
          double x, y, z;
          pcl::PointXYZ _pt;
          x = px(0)*t*t*t*t*t*t*t/5040 - px(1)*t*t*t*t*t*t/720 + px(2)*t*t*t*t*t/120 - px(3)*t*t*t*t/24 + px(4)*t*t*t/6 + px(5)* t*t/2 + px(6)*t + px(7);
          y = py(0)*t*t*t*t*t*t*t/5040 - py(1)*t*t*t*t*t*t/720 + py(2)*t*t*t*t*t/120 - py(3)*t*t*t*t/24 + py(4)*t*t*t/6 + py(5)* t*t/2 + py(6)*t + py(7);
          z = pz(0)*t*t*t*t*t*t*t/5040 - pz(1)*t*t*t*t*t*t/720 + pz(2)*t*t*t*t*t/120 - pz(3)*t*t*t*t/24 + pz(4)*t*t*t/6 + pz(5)* t*t/2 + pz(6)*t + pz(7);      
          _pt.x = x;
          _pt.y = y;
          _pt.z = z;
          selected_traj_cloud.points.push_back(_pt);      
          
        }
      }
      /*else
      {
        cout <<"target occluded"<<endl;
        local_goal[0] = localGoal(0); local_goal[1] = localGoal(1); local_goal[2] = localGoal(2); local_goal[3] = maxVel;
        finalTrajectory(px, py, pz, yaw_coeff, controlHorizonTime, T);
        replan = true;
      }*/ 

 
    }

    sensor_msgs::PointCloud2 final_traj;
    pcl::toROSMsg(selected_traj_cloud, final_traj);
    final_traj.header.frame_id = "world";
    final_traj.header.stamp = ros::Time::now();
    selected_traj_pub.publish(final_traj);

    //trajectoryAvailable = true;
    ros::Time t = ros::Time::now();

    cout << "Time taken in trajectory generation: " << t-t0 << "sec" << endl;
    outdata2 <<t-t0 <<","<<local_goal[3]<<","<<currentState(0)<<","<<currentState(4)<<","<<currentState(8)<<","<<initialState(0)<<","<<initialState(4)<<","<<initialState(8)<<endl;     

    
  }
 
  pc_counter += 1;  




}

    

