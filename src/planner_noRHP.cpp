#include <planner_noRHP.h>


using namespace std;
Eigen::Matrix4f lidar_pose;
std::ofstream outdata;
//outdata.open("generated_trajectory.txt", std::ios::out|std::ios::binary);


void planner::getParameters()
{
  
  ROS_INFO("getting all the parameters from launch file");
  // planner parameters
  nh_.param<std::string>("run_number", run_number, "0");
  nh_.param<std::string>("mode", mode, "simulation"); 
  nh_.param<std::string>("px4_controller_type", px4_controller_type, "position"); 
  nh_.param<std::string>("odometry_topic", odom_topic, "/odometry_topic");    
  nh_.param<double>("odometry_frequency", odom_frequency, 100.0);  
  nh_.param<std::string>("cmd_topic", cmd_topic, "/cmd_topic"); 

  nh_.param<double>("mass", mass, 1.0);
  nh_.param<double>("max_thrust", maxT, 35.0);
  nh_.param<double>("max_velocity", maxV, 10.0);
  nh_.param<double>("max_angularvelocity", maxAngV, 35.0);
  nh_.param<std::string>("posecmd_topic", posecmd_topic, "/position_cmd_topic");
  nh_.param<double>("hovering_height", hHover, 1.0);
  nh_.param<std::vector <double>>("initial_position", iPosition, {0, 0, 0.08});
  nh_.param<std::vector <double>>("final_goal", final_goal, {0, 0, 2});   
  //additional parameters for controller
  nh_.param<double>("tau_rp", tau_rp, 1.0);
  nh_.param<double>("tau_yaw", tau_yaw, 1.0);
  nh_.param<std::vector <double>>("kx", kx, {5, 5, 5});
  nh_.param<std::vector <double>>("kv", kv, {4, 4, 4});
  nh_.param<std::vector <double>>("kR", kR, {5, 5, 5});
  nh_.param<std::vector <double>>("kOmega", kOmega, {4, 4, 4});

  nh_.param<double>("battery_percentage", _bat, 100.0);
  nh_.param<std::string>("battery_topic", battery_topic, "/battery_topic");  

  delt = 1.0/odom_frequency;
  //controlHorizonTime = 1.0/pc_frequency;
  //waypointList = {{iPosition[0], iPosition[1], hHover},
  //                {6.0, 7.0, hHover},   
  //                {final_goal[0], final_goal[1], final_goal[2]}, 
  //                {final_goal[0], final_goal[1], 0.1}};

  waypointList = {{iPosition[0], iPosition[1], hHover}, {iPosition[0], iPosition[1], 0.1}};


  outdata.open("_subscribed_trajectory"+run_number+".txt", std::ios::out|std::ios::binary);
  outdata1.open("_generated_trajectory"+run_number+".txt", std::ios::out|std::ios::binary);
  outdata2.open("_other_parameters"+run_number+".txt", std::ios::out|std::ios::binary);
}

void planner::initializeSubscribers()
{
  ROS_INFO("Initializing Planner Subscribers");
  odom_sub1 = nh_.subscribe(odom_topic.c_str(), 1, &planner::odometryCb1, this, ros::TransportHints().tcpNoDelay(true));  
  odom_sub2 = nh_.subscribe(odom_topic.c_str(), 1, &planner::odometryCb2, this, ros::TransportHints().tcpNoDelay(true)); 
  //bat_sub = nh_.subscribe(battery_topic.c_str(), 1, &planner::batteryCb, this, ros::TransportHints().tcpNoDelay(true));
}

void planner::initializePublishers()
{
  ROS_INFO("Initializing Planner Publishers");
  bool latch;
  if (mode ==  "simulation")
  {
    cmd_pub = nh_.advertise<mav_msgs::Actuators>(cmd_topic.c_str(), 1, latch=true);
  }
  else if (mode == "hardware")
  {
    cmd_pub = nh_.advertise<mavros_msgs::AttitudeTarget>(cmd_topic.c_str(), 1, latch=true);
    pose_pub = nh_.advertise<mavros_msgs::PositionTarget>(posecmd_topic.c_str(), 1, latch=true);
  }

  best_traj_pub = nh_.advertise<sensor_msgs::PointCloud2>("/best_trajectory", 1, latch=true);
}

void planner::batteryCb(const sensor_msgs::BatteryState::ConstPtr& msg)
{
  percentage = 100 * msg->percentage;
  if (percentage >= 40.0 && percentage <= 100.0)
  {
    // 2nd order polynomial fit with battery percentage and max thrust generated by propellers
    maxT = -0.0011847886*percentage*percentage + 0.2761785826*percentage + 19.3783082048;
  }
  else
  {
    maxT = 50.0; // a high value so that the quad cant take off
    cout<<"Not safe for flying: Battery percentage is less than 40 or greater than 100"<<endl; 
  }
}


void planner::checkConvergance(VectorXd& goalState, VectorXd& currentState, bool& waypointReached, double& convergance)
{
  convergance = sqrt(pow(goalState(0)-currentState(0), 2) + pow(goalState(4)-currentState(4), 2) + pow(goalState(8)-currentState(8), 2));

  if (convergance <=0.1 && wp_counter < waypointList.size()-1 && !waypointReached)
  {
    wp_counter += 1;
    //cout<<"i m here"<<endl;
    initialState << waypointList[wp_counter-1][0], 0.0, 0.0, 0.0, 
                    waypointList[wp_counter-1][1], 0.0, 0.0, 0.0, 
                    waypointList[wp_counter-1][2], 0.0, 0.0, 0.0;
    goalState << waypointList[wp_counter][0], 0.0, 0.0, 0.0, waypointList[wp_counter][1], 0.0, 0.0, 0.0, waypointList[wp_counter][2], 0.0, 0.0, 0.0;
    waypointReached  = true;
  }
  /*else if (convergance > 0.1 || wp_counter >= waypointList.size()-1)
  {
    waypointReached = false;
  }*/
}

void planner::finalTrajectory(VectorXd& px, VectorXd& py, VectorXd& pz, Vector4d& yaw_coeff, double& T0, double& T)
{
  //outdata.open("generated_trajectory.txt", std::ios::out|std::ios::binary);  
  //cout << "in cb1"<<endl;
  int n = int(T/delt) + 1;
  VectorXd timePoints(n);
  timePoints[0] = T0;
  for (int i = 0; i < (n - 1); ++i)
  {
    timePoints[i] =  delt * i;
  }
  timePoints[n-1] = T;
  double start_time = ros::Time::now().toSec();

  for (int i=0; i<timePoints.size(); i++)
  {
    double t = timePoints(i);
    double _time = start_time + t;
    double x, y, z, vx, vy, vz, ax, ay, az, jx, jy, jz, phi, phi_r;
    pcl::PointXYZ pt;
    x = px(0)*t*t*t*t*t*t*t/5040 - px(1)*t*t*t*t*t*t/720 + px(2)*t*t*t*t*t/120 - px(3)*t*t*t*t/24 + px(4)*t*t*t/6 + px(5)* t*t/2 + px(6)*t + px(7);
    y = py(0)*t*t*t*t*t*t*t/5040 - py(1)*t*t*t*t*t*t/720 + py(2)*t*t*t*t*t/120 - py(3)*t*t*t*t/24 + py(4)*t*t*t/6 + py(5)* t*t/2 + py(6)*t + py(7);
    z = pz(0)*t*t*t*t*t*t*t/5040 - pz(1)*t*t*t*t*t*t/720 + pz(2)*t*t*t*t*t/120 - pz(3)*t*t*t*t/24 + pz(4)*t*t*t/6 + pz(5)* t*t/2 + pz(6)*t + pz(7);

    vx = px(0)*t*t*t*t*t*t/720 - px(1)*t*t*t*t*t/120 + px(2)*t*t*t*t/24 - px(3)*t*t*t/6 + px(4)*t*t/2 + px(5)* t + px(6);
    vy = py(0)*t*t*t*t*t*t/720 - py(1)*t*t*t*t*t/120 + py(2)*t*t*t*t/24 - py(3)*t*t*t/6 + py(4)*t*t/2 + py(5)* t + py(6);
    vz = pz(0)*t*t*t*t*t*t/720 - pz(1)*t*t*t*t*t/120 + pz(2)*t*t*t*t/24 - pz(3)*t*t*t/6 + pz(4)*t*t/2 + pz(5)* t + pz(6);

    ax = px(0)*t*t*t*t*t/120 - px(1)*t*t*t*t/24 + px(2)*t*t*t/6 - px(3)*t*t/2 + px(4)*t + px(5);
    ay = py(0)*t*t*t*t*t/120 - py(1)*t*t*t*t/24 + py(2)*t*t*t/6 - py(3)*t*t/2 + py(4)*t + py(5);
    az = pz(0)*t*t*t*t*t/120 - pz(1)*t*t*t*t/24 + pz(2)*t*t*t/6 - pz(3)*t*t/2 + pz(4)*t + pz(5);

    phi = yaw_coeff(0) + yaw_coeff(1)*t + yaw_coeff(2) *t*t + yaw_coeff(3) *t*t*t;
    phi_r = yaw_coeff(1) + 2 *yaw_coeff(2) *t + 3 *yaw_coeff(3) *t*t;

    outdata1 << _time <<","<<x<<","<<y<<","<<z<<","<<vx<<","<<vy<<","<<vz<<","<<ax<<","<<ay<<","<<az<<","<<phi<<","<<phi_r<<endl;

    pt.x = x;
    pt.y = y;
    pt.z = z;
    traj_cloud.points.push_back(pt);
    
    traj_global_time.push_back(_time);
    xdes.push_back(x); ydes.push_back(y); zdes.push_back(z);
    vxdes.push_back(vx); vydes.push_back(vy); vzdes.push_back(vz);
    axdes.push_back(ax); aydes.push_back(ay); azdes.push_back(az);
    yawdes.push_back(phi); yawratedes.push_back(phi_r);
    if (traj_global_time.size() >= 2000)
    {
      traj_global_time.erase(traj_global_time.begin());
      xdes.erase(xdes.begin()); ydes.erase(ydes.begin()); zdes.erase(zdes.begin());
      vxdes.erase(vxdes.begin()); vydes.erase(vydes.begin()); vzdes.erase(vzdes.begin());
      axdes.erase(axdes.begin()); aydes.erase(aydes.begin()); azdes.erase(azdes.begin());
      yawdes.erase(yawdes.begin()); yawratedes.erase(yawratedes.begin());
    }
    
  }
  //outdata<< "trajectory publishing ends"<<","<<ros::Time::now().toSec()<<endl;
  trajectoryAvailable = true;
  sensor_msgs::PointCloud2 pc_traj;
  pcl::toROSMsg(traj_cloud, pc_traj);
  pc_traj.header.frame_id = "map";
  pc_traj.header.stamp = ros::Time::now();
  best_traj_pub.publish(pc_traj);
}

void planner::odometryCb1(const nav_msgs::Odometry::ConstPtr& msg)
{
  current_time = msg->header.stamp.toSec();
  Eigen::Quaterniond q;
  q.w() = msg->pose.pose.orientation.w;
  q.x() = msg->pose.pose.orientation.x;
  q.y() = msg->pose.pose.orientation.y;
  q.z() = msg->pose.pose.orientation.z;
  Eigen::Matrix3d R = q.toRotationMatrix();


  
  Eigen::Vector3d Vc = {msg->twist.twist.linear.x, msg->twist.twist.linear.y, msg->twist.twist.linear.z};
  //converting velocity from /udrone1/mavros/odometry/in in the global frame 
  Vc = R*Vc; 
  //converting velocity from /udrone1/mavros/odometry/in in the global frame 

  /*if (odom1_counter == 0)
  {
    // 0.1 is added to z of initialState because the odometry--due to the noises-- gives negative z velocities
    // and ex and ev in the controller are so small that quad goes slightly downwards and since its already 
    // on the ground, collision is detected and current odometry has nan velocities
    initialState << msg->pose.pose.position.x, Vc(0), 0.0, 0.0, 
                    msg->pose.pose.position.y, Vc(1), 0.0, 0.0, 
                    msg->pose.pose.position.z, Vc(2), 0.0, 0.0;
    goalState << waypointList[wp_counter][0], 0.0, 0.0, 0.0, waypointList[wp_counter][1], 0.0, 0.0, 0.0, waypointList[wp_counter][2], 0.0, 0.0, 0.0;
  }*/

  currentState << msg->pose.pose.position.x, Vc(0), 0.0, 0.0, 
                  msg->pose.pose.position.y, Vc(1), 0.0, 0.0, 
                  msg->pose.pose.position.z, Vc(2), 0.0, 0.0;

  currentYaw = tf2::getYaw(msg->pose.pose.orientation);
  currentYawrate = 0.0;

  if (trajectoryAvailable)
  {
    int j;
    for (int i = traj_global_time.size()-1; i >= 0; --i)
    {
      if (traj_global_time[i] < current_time)
      {
        j = i;
        break;
      }
      else
      {
        j = traj_global_time.size()-1;
      }
      
    }

    desiredState<< xdes[j], vxdes[j], axdes[j], 0.0, ydes[j], vydes[j], aydes[j], 0.0, zdes[j], vzdes[j], azdes[j], 0.0, yawdes[j], yawratedes[j];
    
    outdata<<traj_global_time[j]<<","<<desiredState(0)<<","<<currentState(0)<<","<<desiredState(4)<<","<<currentState(4)<<","<<desiredState(8)
            <<","<<currentState(8)<<","<<desiredState(1)<<","<<currentState(1)<<","<<desiredState(5)<<","<<currentState(5)<<","
            <<desiredState(9)<<","<<currentState(9)<<","<<desiredState(2)<<","<<currentState(2)<<","<<desiredState(6)<<","<<currentState(6)<<","
            <<desiredState(10)<<","<<currentState(10)<<","<<desiredState(12)<<","<<currentYaw<<","<<desiredState(13)<<","<<currentYawrate<<endl;

    if (mode == "simulation")
    {
      controller_simulation control;
      Eigen::VectorXd w(6);
      control.calculateCommands(msg, desiredState, kx, kx, kR, kOmega, mass, w);

      mav_msgs::Actuators cmd_msg;
      cmd_msg.header.stamp = msg->header.stamp;
      for (int i; i< w.size(); i++)
      {
        cmd_msg.angular_velocities.push_back(w(i)); 
      }
      cmd_pub.publish(cmd_msg);
    }
    else if (mode == "hardware")
    {
      if (px4_controller_type == "attitude")
      {
        controller_px4 control;
        Eigen::VectorXd w(4);
        control.calculateCommands(msg, desiredState, kx, kx, tau_rp, tau_yaw, maxT, mass, w);
        mavros_msgs::AttitudeTarget cmd_msg;
        cmd_msg.header.stamp = ros::Time::now();//msg->header.stamp;
        cmd_msg.type_mask = 128;
        cmd_msg.body_rate.x = w(0);
        cmd_msg.body_rate.y = w(1);
        cmd_msg.body_rate.z = w(2);
        cmd_msg.thrust = w(3);
        cmd_pub.publish(cmd_msg);
      }
      else if(px4_controller_type == "position")
      {
	//cout << "in position COntroller"<<endl;
	//uint16 type_mask
	// uint16 IGNORE_PX = 1 # position ignore flags
	// uint16 IGNORE_PY = 2
	// uint16 IGNORE_PZ = 4
	// uint16 IGNORE_VX = 8 # velocity vector ignore flags
	// uint16 IGNORE_VY = 16
	// uint16 IGNORE_VZ = 32
	// uint16 IGNORE_AFX = 64 # acceleration/force vector ignore flags
	// uint16 IGNORE_AFY = 128
	// uint16 IGNORE_AFZ = 256
	// uint16 FORCE = 512
	// uint16 IGNORE_YAW = 1028
	// uint16 IGNORE_YAW_RATE = 2014

        mavros_msgs::PositionTarget posecmd_msg;
	posecmd_msg.coordinate_frame = mavros_msgs::PositionTarget::FRAME_BODY_NED;
	posecmd_msg.header.stamp = ros::Time::now();
        posecmd_msg.type_mask = 8+16+32+64+128+256+512;

	posecmd_msg.position.x = desiredState(0);
	posecmd_msg.position.y = desiredState(4);
	posecmd_msg.position.z = desiredState(8);
	posecmd_msg.velocity.x = desiredState(1);
	posecmd_msg.velocity.y = desiredState(5);
	posecmd_msg.velocity.z = desiredState(9);
	posecmd_msg.acceleration_or_force.x = desiredState(2);
	posecmd_msg.acceleration_or_force.y = desiredState(6);
	posecmd_msg.acceleration_or_force.z = desiredState(10);
	posecmd_msg.yaw = desiredState(12);
	posecmd_msg.yaw_rate = desiredState(13);
        pose_pub.publish(posecmd_msg);
        //cout <<desiredState(12)<<","<<desiredState(13)<<endl; 
 
      }
    }
    

  }

  odom1_counter += 1;
}

void planner::odometryCb2(const nav_msgs::Odometry::ConstPtr& msg)
{
  clock_t start, end;
  start = clock(); 
  double convergance, time_taken;
  time_taken = double(start) / double(CLOCKS_PER_SEC); 
  //cout << "start: " << fixed << time_taken << setprecision(7) << "sec" << endl;
  double T0 = 0.0;
  bool badTrajectory;
  OptimalControlTrajectory trajectory;

    
  checkConvergance(goalState, currentState, waypointReached, convergance);
  /*if (abs(goalState(0) - initialState(0))<0.05 && abs(goalState(4) - initialState(4))<0.05)
  {desiredYaw = 0;}
  else {desiredYaw = atan2(goalState(4) - initialState(4), goalState(0) - initialState(0));}*/
  Eigen::Vector2d yaw_ic, yaw_fc;
  Eigen::Vector4d yaw_coeff;
  //yaw_ic << currentYaw, currentYawrate;
  //yaw_fc << desiredYaw, 0.0;
  cout <<"convergance:" <<convergance<<endl;

  if (waypointReached || odom2_counter == 0 ) // pc_counter condition is added because I am not getting a good logic at very first point
  {
    if (wp_counter == 0 || wp_counter == waypointList.size()-1)
    {

      initialState = currentState;
      if (wp_counter == 0)
      {
        goalState << initialState(0), 0.0, 0.0, 0.0,
                     initialState(4), 0.0, 0.0, 0.0,
                     hHover, 0.0, 0.0, 0.0; 
      }
      else
      {
        goalState << initialState(0), 0.0, 0.0, 0.0,
                     initialState(4), 0.0, 0.0, 0.0,
                     0.2, 0.0, 0.0, 0.0; 
      } 
      /*if (wp_counter == waypointList.size()-1 && waypointList.size() != 2)
      {
        initialState << local_goal[0], 0.0, 0.0, 0.0, local_goal[1], 0.0, 0.0, 0.0, local_goal[2], 0.0, 0.0, 0.0;
        goalState << local_goal[0], 0.0, 0.0, 0.0, local_goal[1], 0.0, 0.0, 0.0, 0.15, 0.0, 0.0, 0.0;           
      }
      else if(wp_counter == waypointList.size()-1 && waypointList.size() == 2)
      {
        //initialState = goalState;
        //goalState << goalState(0), 0.0, 0.0, 0.0, goalState(1), 0.0, 0.0, 0.0, 0.15, 0.0, 0.0, 0.0;
        initialState << waypointList[wp_counter-1][0], 0.0, 0.0, 0.0, 
                        waypointList[wp_counter-1][1], 0.0, 0.0, 0.0, 
                        waypointList[wp_counter-1][2], 0.0, 0.0, 0.0;
        goalState << waypointList[wp_counter][0], 0.0, 0.0, 0.0, waypointList[wp_counter][1], 0.0, 0.0, 0.0, waypointList[wp_counter][2], 0.0, 0.0, 0.0;
      }*/
      yaw_ic << currentYaw, currentYawrate;
      yaw_fc = yaw_ic;
      double hoverMaxV = 0.5;
      cout << "initialState:"<<initialState(0)<<","<<initialState(4)<<","<<initialState(8)<<endl;
      cout << "goalState:"<<goalState(0)<<","<<goalState(4)<<","<<goalState(8)<<endl;

      trajectory.generateTrajectory(initialState, goalState, hoverMaxV, maxT, maxAngV, mass, px, py, pz, T, badTrajectory);
      trajectory.yawCoeff(yaw_ic, yaw_fc, T, yaw_coeff);
      finalTrajectory(px, py, pz, yaw_coeff, T0, T);
      cout <<T<<endl;
      ros::Duration(T+10.0).sleep();
      cout<<"done sleeping:"<<ros::Duration(T+10.0)<<endl;       
      wp_counter +=1;
      waypointReached = true;

      if (wp_counter == waypointList.size())
      {
        waypointReached = false;
        replan = false;
      }
      
    }
    /*else
    {
      cout <<"here"<<endl;
      waypointReached = false;
      trajectory.generateTrajectory(initialState, goalState, maxV, maxT, maxAngV, mass, px, py, pz, T, badTrajectory);
      trajectory.yawCoeff(yaw_ic, yaw_fc, T, yaw_coeff);
      finalTrajectory(px, py, pz, yaw_coeff, T0, T);
      ros::Duration(T+1.0).sleep();
      wp_counter +=1;
      initialState << waypointList[wp_counter-1][0], 0.0, 0.0, 0.0, 
                      waypointList[wp_counter-1][1], 0.0, 0.0, 0.0, 
                      waypointList[wp_counter-1][2], 0.0, 0.0, 0.0;
      goalState << waypointList[wp_counter][0], 0.0, 0.0, 0.0, waypointList[wp_counter][1], 0.0, 0.0, 0.0, waypointList[wp_counter][2], 0.0, 0.0, 0.0;
      waypointReached = true;
      
      
    }*/
    //trajectoryAvailable = true;
    end = clock(); 
    time_taken = double(end) / double(CLOCKS_PER_SEC); 
    cout << "end: " << fixed << time_taken << setprecision(7) << "sec" << endl;
    time_taken = double(end - start) / double(CLOCKS_PER_SEC); 
    cout << "Time taken in trajectory generation: " << fixed << time_taken << setprecision(7) << "sec" << endl; 
    //ros::Duration(T+1.0).sleep();      
  }
  

  odom2_counter += 1;  


}

    

